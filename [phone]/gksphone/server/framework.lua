
-- Phone Item Use Event

for index in pairs(Config.ItemName) do
    Config.Core.Functions.CreateUseableItem(index, function(source, item)
      TriggerClientEvent('gksphone:client:usePhone', source, item)
    end)
end

--- FreameWork Notify ---

FreamworkNotify = function(source, message, notifyType, length)
  notifyType = notifyType or "success"
  length = length or 5000
  TriggerClientEvent('QBCore:Notify', source, message, notifyType, length)
end

--- Phone Unique ID ---

local function randomString(length)
  local chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  local result = ''
  for _ = 1, length do
      local rand = math.random(#chars)
      result = result .. chars:sub(rand, rand)
  end
  return result
end

-- Generates a unique serial number for the phone.
-- The serial number is generated by combining a prefix, the current date, and a random string.
-- The generated serial number is checked against the database to ensure its uniqueness.
-- If a duplicate serial number is found, the function will generate a new one.
-- Returns the generated serial number.
function generateSerialNumber()
  :: generateSerial ::
  local prefix = Config.SerialNumberPrefix
  local date = os.date("%Y%m")
  local serial = randomString(4)
  local serialNumber = prefix .. date .. serial
  local result = MySQL.Sync.fetchScalar('SELECT COUNT(*) FROM gksphone_settings WHERE unique_id = ?', {serialNumber})
  if result > 0 then
    goto generateSerial
  end
  return serialNumber
end

--- Create Phone Number ---

-- Creates a unique phone number by generating a random 8-digit number and checking if it already exists in the database.
-- If the generated number already exists, it generates a new number until a unique one is found.
-- Returns the generated phone number as a string.
function CreatePhoneNumber()
  :: createNumber ::
  local PhoneNumber = math.random(10000000, 99999999)
  local query = '%' .. PhoneNumber .. '%'
  local result = MySQL.Sync.fetchScalar('SELECT COUNT(*) FROM gksphone_esim WHERE phone_number LIKE ?', { query })
  if result > 0 then
    goto createNumber
  end
  return tostring(PhoneNumber)
end

--- Set Item Data ---

-- Sets the metadata of an item for a player.
--- @param source number The player's source ID.
--- @param item table The item to set the metadata for.
--- @param data table The metadata to set.
-- @return True if the metadata was set successfully, false otherwise.
function SetItemData(source, item, data)
  local src = source
  local Player = Config.Core.Functions.GetPlayer(src)
  if Player then
    if Config.OxInvetory then
      exports.ox_inventory:SetMetadata(src, item.slot, data)
      return true
    elseif Config.CoreInventory then
      local inventory = 'content-' ..  Player.PlayerData.citizenid
      exports['core_inventory']:updateMetadata(inventory, item.id, data)
      return true
    elseif Config.qsInvetory then
      exports['qs-inventory']:SetItemMetadata(src, item.slot, data)
      return true
    elseif Config.tgiannInventory then
      exports['tgiann-inventory']:UpdateItemMetadata(src, item.name, item.slot, data)
      return true
    elseif not Config.MetaItem then
      return true
    else
      local itemData = Player.Functions.GetItemBySlot(item.slot)
      if itemData ~= nil then
        Player.PlayerData.items[itemData.slot].info = data
        Player.Functions.SetInventory(Player.PlayerData.items)
        return true
      end
    end
  end
  return false
end

--- Updates the metadata of an item for a player based on the provided datatype and data.
--- @param source number The player's source ID.
--- @param item table The item to update the metadata for.
--- @param datatype string The type of metadata to update.
--- @param data any The new data to set for the specified metadata type.
function UpdateItemData(source, item, datatype, data)
  debugprint('UpdateItemData', source, item, datatype, data)
  local src = source
  local metadata = item.metadata or item.info
  metadata[datatype] = data
  if Config.OxInvetory then
    exports.ox_inventory:SetMetadata(src, item.slot, metadata)
  elseif Config.CoreInventory then
    local Player = Config.Core.Functions.GetPlayer(src)
    if Player == nil then return false end
    local inventory = 'content-' ..  Player.PlayerData.citizenid
    exports['core_inventory']:updateMetadata(inventory, item.id, metadata)
  elseif Config.qsInvetory then
    exports['qs-inventory']:SetItemMetadata(src, item.slot, metadata)
  elseif Config.tgiannInventory then
    exports['tgiann-inventory']:UpdateItemMetadata(src, item.name, item.slot, metadata)
    return true
  else
    local Player = Config.Core.Functions.GetPlayer(src)
    if Player then
      local itemData = Player.Functions.GetItemBySlot(item.slot)
      if itemData ~= nil then
        Player.PlayerData.items[itemData.slot].info = metadata
        Player.Functions.SetInventory(Player.PlayerData.items)
      end
    end
  end
end

function SearchPhoneItems(source)
  local src = source
  local Player = Config.Core.Functions.GetPlayer(src)
  local itemData = {}
  local items = {}
  local data = {}
  if Player then
    if Config.qsInvetory then
      items = {}
      data = exports['qs-inventory']:GetInventory(src)
    elseif Config.CoreInventory then
      items = {}
      local inventory = 'content-' ..  Player.PlayerData.citizenid
      data = exports['core_inventory']:getInventory(inventory)
    elseif Config.tgiannInventory then
      items = {}
      data = exports["tgiann-inventory"]:GetPlayerItems(src)
    end
    for k, v in pairs(Config.ItemName) do
      if Config.OxInvetory then
        itemData = exports.ox_inventory:Search(src, 1, k)
      elseif Config.CoreInventory then
        if data and type(data) =="table" then
          for x,y in pairs(data) do
              if y.name == k then
                  items[#items+1] = y
              end
          end
        end
        if #items > 0 then
          itemData = items
        end
      elseif Config.qsInvetory then
        if data and type(data) =="table" then
          for _, l in pairs(data) do
            if l.name == k then
              items[#items+1] = l
            end
          end
        end
        if #items > 0 then
          itemData = items
        end
      elseif Config.tgiannInventory then
        if data and type(data) =="table" then
          for _, l in pairs(data) do
            if l.name == k then
              items[#items+1] = l
            end
          end
        end
        if #items > 0 then
          itemData = items
        end
      else
        itemData = Player.Functions.GetItemsByName(k)
      end
      if #itemData > 0 then
        return itemData
      end
    end
  end
  return itemData
end

--- Get Item Data ---

function GetItemData(source, phoneUniqID)
  local Player = Config.Core.Functions.GetPlayer(source)
  if Player then
    local items = Player.PlayerData.items
    for _, v in pairs(items) do
      if v.info ~= nil then
        if v.info.phoneUniqID ~= nil then
          if v.info.phoneUniqID == phoneUniqID then
            return v
          end
        end
      end
    end
  end
end


-- Powerbank Item Use Event
if ChargeOn then
  for _, value in ipairs(Config.ChargeItems) do
    Config.Core.Functions.CreateUseableItem(value, function(source)
      local src = source
      local Player = Config.Core.Functions.GetPlayer(src)
      if Player and Player.Functions.RemoveItem(value, 1) then
        TriggerClientEvent('gksphone:client:powerbank', src)
      end
    end)
  end
end

--- Society Money ----

function SocietyGetMoney(jobname)
  local BusinessMoney = 0
  if GetResourceState("qb-banking") == "started" then
    BusinessMoney = exports['qb-banking']:GetAccount(jobname)?.account_balance or 0
  end

  return BusinessMoney
end

function SocietyRemoveMoney(job, amount)
  local process = false
  if GetResourceState("qb-banking") == "started" then
    local jobPrice = SocietyGetMoney(job)
    if jobPrice >= amount then
      if exports['qb-banking']:RemoveMoney(job, amount) then
        process = true
      end
    end
  end
  return process
end

function SocietyAddMoney(job, amount)
  local process = false
  if GetResourceState("qb-banking") == "started" then
    if exports['qb-banking']:AddMoney(job, amount) then
      process = true
    end
  end
  return process
end

---- IsDead Inlaststand ---

function CallingPlayerStatus(source)
  local retval = false
  local Player = Config.Core.Functions.GetPlayer(source)
  if Player.PlayerData.metadata["ishandcuffed"] or Player.PlayerData.metadata["isdead"] or Player.PlayerData.metadata["inlaststand"] then
    retval = true
  end
  return retval
end

--- Auto Open Close Dispatch ---

if Config.IsDispatchAutoOpenClose then
  RegisterNetEvent('QBCore:Server:OnJobUpdate', function(source, newJob)
    if not Config.JOBDispatch[newJob.name] or Config.DispatchAutoIgnoredJobs[newJob.name] then return end
    local PolicesOnDuty, count = Config.Core.Functions.GetPlayersOnDuty(newJob.name)
    if count == 0 then
      local isJobActive = exports["gksphone"]:IsJobStatus(newJob.name)
      if isJobActive then
        exports["gksphone"]:JobStatusChange(newJob.name, false)
      end
    elseif count == 1 then
      local isJobActive = exports["gksphone"]:IsJobStatus(newJob.name)
      if not isJobActive then
        exports["gksphone"]:JobStatusChange(newJob.name, true)
      end
    end
  end)
end

--- Delete Character ---
--- Delete Character Event ---
if Config.deleteCharacter then
  RegisterNetEvent("qb-multicharacter:server:deleteCharacter", function (citizenid)
    DeleteCharacter(citizenid)
  end)
end
